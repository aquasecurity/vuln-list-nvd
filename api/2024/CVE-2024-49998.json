{
  "id": "CVE-2024-49998",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-10-21T18:15:19.907",
  "lastModified": "2024-10-23T15:13:25.583",
  "vulnStatus": "Awaiting Analysis",
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: dsa: improve shutdown sequence\n\nAlexander Sverdlin presents 2 problems during shutdown with the\nlan9303 driver. One is specific to lan9303 and the other just happens\nto reproduce there.\n\nThe first problem is that lan9303 is unique among DSA drivers in that it\ncalls dev_get_drvdata() at \"arbitrary runtime\" (not probe, not shutdown,\nnot remove):\n\nphy_state_machine()\n-\u003e ...\n   -\u003e dsa_user_phy_read()\n      -\u003e ds-\u003eops-\u003ephy_read()\n         -\u003e lan9303_phy_read()\n            -\u003e chip-\u003eops-\u003ephy_read()\n               -\u003e lan9303_mdio_phy_read()\n                  -\u003e dev_get_drvdata()\n\nBut we never stop the phy_state_machine(), so it may continue to run\nafter dsa_switch_shutdown(). Our common pattern in all DSA drivers is\nto set drvdata to NULL to suppress the remove() method that may come\nafterwards. But in this case it will result in an NPD.\n\nThe second problem is that the way in which we set\ndp-\u003econduit-\u003edsa_ptr = NULL; is concurrent with receive packet\nprocessing. dsa_switch_rcv() checks once whether dev-\u003edsa_ptr is NULL,\nbut afterwards, rather than continuing to use that non-NULL value,\ndev-\u003edsa_ptr is dereferenced again and again without NULL checks:\ndsa_conduit_find_user() and many other places. In between dereferences,\nthere is no locking to ensure that what was valid once continues to be\nvalid.\n\nBoth problems have the common aspect that closing the conduit interface\nsolves them.\n\nIn the first case, dev_close(conduit) triggers the NETDEV_GOING_DOWN\nevent in dsa_user_netdevice_event() which closes user ports as well.\ndsa_port_disable_rt() calls phylink_stop(), which synchronously stops\nthe phylink state machine, and ds-\u003eops-\u003ephy_read() will thus no longer\ncall into the driver after this point.\n\nIn the second case, dev_close(conduit) should do this, as per\nDocumentation/networking/driver.rst:\n\n| Quiescence\n| ----------\n|\n| After the ndo_stop routine has been called, the hardware must\n| not receive or transmit any data.  All in flight packets must\n| be aborted. If necessary, poll or wait for completion of\n| any reset commands.\n\nSo it should be sufficient to ensure that later, when we zeroize\nconduit-\u003edsa_ptr, there will be no concurrent dsa_switch_rcv() call\non this conduit.\n\nThe addition of the netif_device_detach() function is to ensure that\nioctls, rtnetlinks and ethtool requests on the user ports no longer\npropagate down to the driver - we're no longer prepared to handle them.\n\nThe race condition actually did not exist when commit 0650bf52b31f\n(\"net: dsa: be compatible with masters which unregister on shutdown\")\nfirst introduced dsa_switch_shutdown(). It was created later, when we\nstopped unregistering the user interfaces from a bad spot, and we just\nreplaced that sequence with a racy zeroization of conduit-\u003edsa_ptr\n(one which doesn't ensure that the interfaces aren't up)."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: net: dsa: mejorar la secuencia de apagado Alexander Sverdlin presenta 2 problemas durante el apagado con el controlador lan9303. Uno es específico de lan9303 y el otro simplemente se reproduce allí. El primer problema es que lan9303 es único entre los controladores DSA en el sentido de que llama a dev_get_drvdata() en un \"tiempo de ejecución arbitrario\" (no sondeo, no apagado, no eliminación): phy_state_machine() -\u0026gt; ... -\u0026gt; dsa_user_phy_read() -\u0026gt; ds-\u0026gt;ops-\u0026gt;phy_read() -\u0026gt; lan9303_phy_read() -\u0026gt; chip-\u0026gt;ops-\u0026gt;phy_read() -\u0026gt; lan9303_mdio_phy_read() -\u0026gt; dev_get_drvdata() Pero nunca detenemos phy_state_machine(), por lo que puede continuar ejecutándose después de dsa_switch_shutdown(). Nuestro patrón común en todos los controladores DSA es establecer drvdata en NULL para suprimir el método remove() que puede venir después. Pero en este caso resultará en un NPD. El segundo problema es que la forma en que establecemos dp-\u0026gt;conduit-\u0026gt;dsa_ptr = NULL; es concurrente con el procesamiento de paquetes de recepción. dsa_switch_rcv() verifica una vez si dev-\u0026gt;dsa_ptr es NULL, pero después, en lugar de continuar usando ese valor no NULL, dev-\u0026gt;dsa_ptr se desreferencia una y otra vez sin verificaciones NULL: dsa_conduit_find_user() y muchos otros lugares. Entre desreferencias, no hay bloqueo para asegurar que lo que era válido una vez continúa siendo válido. Ambos problemas tienen el aspecto común de que cerrar la interfaz del conducto los resuelve. En el primer caso, dev_close(conduit) activa el evento NETDEV_GOING_DOWN en dsa_user_netdevice_event() que también cierra los puertos de usuario. dsa_port_disable_rt() llama a phylink_stop(), que detiene sincrónicamente la máquina de estado de phylink, y ds-\u0026gt;ops-\u0026gt;phy_read() ya no llamará al controlador después de este punto. En el segundo caso, dev_close(conduit) debería hacer esto, según Documentation/networking/driver.rst: | Quiescence | ---------- | | Después de que se haya llamado a la rutina ndo_stop, el hardware no debe recibir ni transmitir ningún dato. Todos los paquetes en tránsito deben ser abortados. Si es necesario, sondee o espere a que se completen los comandos de reinicio. Por lo tanto, debería ser suficiente para garantizar que más adelante, cuando pongamos a cero conduit-\u0026gt;dsa_ptr, no habrá ninguna llamada dsa_switch_rcv() concurrente en este conducto. La adición de la función netif_device_detach() es para garantizar que las solicitudes ioctls, rtnetlinks y ethtool en los puertos de usuario ya no se propaguen al controlador; ya no estamos preparados para manejarlas. La condición de ejecución en realidad no existía cuando el commit 0650bf52b31f (\"net: dsa: sea compatible con los maestros que cancelan el registro al apagar\") introdujo por primera vez dsa_switch_shutdown(). Se creó más tarde, cuando dejamos de cancelar el registro de las interfaces de usuario desde un lugar incorrecto y simplemente reemplazamos esa secuencia con una puesta a cero de ejecución de conduit-\u0026gt;dsa_ptr (que no garantiza que las interfaces no estén activas)."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/6c24a03a61a245fe34d47582898331fa034b6ccd",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/ab5d3420a1120950703dbdc33698b28a6ebc3d23",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/b4a65d479213fe84ecb14e328271251eebe69492",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}