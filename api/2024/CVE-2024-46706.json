{
  "id": "CVE-2024-46706",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-09-13T07:15:05.560",
  "lastModified": "2024-09-13T14:06:04.777",
  "vulnStatus": "Awaiting Analysis",
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\ntty: serial: fsl_lpuart: mark last busy before uart_add_one_port\n\nWith \"earlycon initcall_debug=1 loglevel=8\" in bootargs, kernel\nsometimes boot hang. It is because normal console still is not ready,\nbut runtime suspend is called, so early console putchar will hang\nin waiting TRDE set in UARTSTAT.\n\nThe lpuart driver has auto suspend delay set to 3000ms, but during\nuart_add_one_port, a child device serial ctrl will added and probed with\nits pm runtime enabled(see serial_ctrl.c).\nThe runtime suspend call path is:\ndevice_add\n     |-\u003e bus_probe_device\n           |-\u003edevice_initial_probe\n\t           |-\u003e__device_attach\n                         |-\u003e pm_runtime_get_sync(dev-\u003eparent);\n\t\t\t |-\u003e pm_request_idle(dev);\n\t\t\t |-\u003e pm_runtime_put(dev-\u003eparent);\n\nSo in the end, before normal console ready, the lpuart get runtime\nsuspended. And earlycon putchar will hang.\n\nTo address the issue, mark last busy just after pm_runtime_enable,\nthree seconds is long enough to switch from bootconsole to normal\nconsole."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: tty: serial: fsl_lpuart: marcar el último ocupado antes de uart_add_one_port Con \"earlycon initcall_debug=1 loglevel=8\" en bootargs, el kernel a veces se bloquea al iniciar. Esto se debe a que la consola normal aún no está lista, pero se llama a la suspensión en tiempo de ejecución, por lo que la consola temprana putchar se bloqueará esperando que se establezca TRDE en UARTSTAT. El controlador lpuart tiene un retraso de suspensión automática establecido en 3000 ms, pero durante uart_add_one_port, se agregará un dispositivo secundario serial ctrl y se sondeará con su tiempo de ejecución pm habilitado (consulte serial_ctrl.c). La ruta de la llamada a la suspensión en tiempo de ejecución es: device_add |-\u0026gt; bus_probe_device |-\u0026gt;device_initial_probe |-\u0026gt;__device_attach |-\u0026gt; pm_runtime_get_sync(dev-\u0026gt;parent); |-\u0026gt; pm_request_idle(dev); |-\u0026gt; pm_runtime_put(dev-\u0026gt;parent); Por lo tanto, al final, antes de que la consola normal esté lista, el tiempo de ejecución de lpuart get se suspende. Y el putchar de earlycon se bloquea. Para solucionar el problema, marque la última vez que está ocupado justo después de pm_runtime_enable; tres segundos son suficientes para cambiar de la consola de arranque a la consola normal."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/3ecf625d4acb71d726bc0b49403cf68388b3d58d",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/8eb92cfca6c2c5a15ab1773f3d18ab8d8f7dbb68",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/dc98d76a15bc29a9a4e76f2f65f39f3e590fb15c",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}