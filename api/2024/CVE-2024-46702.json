{
  "id": "CVE-2024-46702",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-09-13T07:15:05.217",
  "lastModified": "2024-09-13T14:06:04.777",
  "vulnStatus": "Awaiting Analysis",
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nthunderbolt: Mark XDomain as unplugged when router is removed\n\nI noticed that when we do discrete host router NVM upgrade and it gets\nhot-removed from the PCIe side as a result of NVM firmware authentication,\nif there is another host connected with enabled paths we hang in tearing\nthem down. This is due to fact that the Thunderbolt networking driver\nalso tries to cleanup the paths and ends up blocking in\ntb_disconnect_xdomain_paths() waiting for the domain lock.\n\nHowever, at this point we already cleaned the paths in tb_stop() so\nthere is really no need for tb_disconnect_xdomain_paths() to do that\nanymore. Furthermore it already checks if the XDomain is unplugged and\nbails out early so take advantage of that and mark the XDomain as\nunplugged when we remove the parent router."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: thunderbolt: marcar XDomain como desconectado cuando se quita el enrutador Noté que cuando hacemos una actualización NVM del enrutador de host discreto y se elimina en caliente del lado PCIe como resultado de la autenticación del firmware NVM, si hay otro host conectado con rutas habilitadas, nos quedamos sin desmantelarlos. Esto se debe al hecho de que el controlador de red Thunderbolt también intenta limpiar las rutas y termina bloqueando en tb_disconnect_xdomain_paths() esperando el bloqueo del dominio. Sin embargo, en este punto ya limpiamos las rutas en tb_stop(), por lo que realmente no hay necesidad de que tb_disconnect_xdomain_paths() haga eso más. Además, ya verifica si el XDomain está desconectado y se retira temprano, así que aproveche eso y marque el XDomain como desconectado cuando eliminemos el enrutador principal."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/18b3ad2a3cc877dd4b16f48d84aa27b78d53bf1d",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/23ce6ba3b95488a2b9e9f6d43b340da0c15395dc",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/747bc154577de6e6af4bc99abfa859b8419bb4d8",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/7ca24cf9163c112bb6b580c6fb57c04a1f8b76e1",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/80ac8d194831eca0c2f4fd862f7925532fda320c",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/e2006140ad2e01a02ed0aff49cc2ae3ceeb11f8d",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}