{
  "id": "CVE-2024-46787",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-09-18T08:15:05.833",
  "lastModified": "2024-09-20T12:30:51.220",
  "vulnStatus": "Awaiting Analysis",
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nuserfaultfd: fix checks for huge PMDs\n\nPatch series \"userfaultfd: fix races around pmd_trans_huge() check\", v2.\n\nThe pmd_trans_huge() code in mfill_atomic() is wrong in three different\nways depending on kernel version:\n\n1. The pmd_trans_huge() check is racy and can lead to a BUG_ON() (if you hit\n   the right two race windows) - I've tested this in a kernel build with\n   some extra mdelay() calls. See the commit message for a description\n   of the race scenario.\n   On older kernels (before 6.5), I think the same bug can even\n   theoretically lead to accessing transhuge page contents as a page table\n   if you hit the right 5 narrow race windows (I haven't tested this case).\n2. As pointed out by Qi Zheng, pmd_trans_huge() is not sufficient for\n   detecting PMDs that don't point to page tables.\n   On older kernels (before 6.5), you'd just have to win a single fairly\n   wide race to hit this.\n   I've tested this on 6.1 stable by racing migration (with a mdelay()\n   patched into try_to_migrate()) against UFFDIO_ZEROPAGE - on my x86\n   VM, that causes a kernel oops in ptlock_ptr().\n3. On newer kernels (\u003e=6.5), for shmem mappings, khugepaged is allowed\n   to yank page tables out from under us (though I haven't tested that),\n   so I think the BUG_ON() checks in mfill_atomic() are just wrong.\n\nI decided to write two separate fixes for these (one fix for bugs 1+2, one\nfix for bug 3), so that the first fix can be backported to kernels\naffected by bugs 1+2.\n\n\nThis patch (of 2):\n\nThis fixes two issues.\n\nI discovered that the following race can occur:\n\n  mfill_atomic                other thread\n  ============                ============\n                              \u003czap PMD\u003e\n  pmdp_get_lockless() [reads none pmd]\n  \u003cbail if trans_huge\u003e\n  \u003cif none:\u003e\n                              \u003cpagefault creates transhuge zeropage\u003e\n    __pte_alloc [no-op]\n                              \u003czap PMD\u003e\n  \u003cbail if pmd_trans_huge(*dst_pmd)\u003e\n  BUG_ON(pmd_none(*dst_pmd))\n\nI have experimentally verified this in a kernel with extra mdelay() calls;\nthe BUG_ON(pmd_none(*dst_pmd)) triggers.\n\nOn kernels newer than commit 0d940a9b270b (\"mm/pgtable: allow\npte_offset_map[_lock]() to fail\"), this can't lead to anything worse than\na BUG_ON(), since the page table access helpers are actually designed to\ndeal with page tables concurrently disappearing; but on older kernels\n(\u003c=6.4), I think we could probably theoretically race past the two\nBUG_ON() checks and end up treating a hugepage as a page table.\n\nThe second issue is that, as Qi Zheng pointed out, there are other types\nof huge PMDs that pmd_trans_huge() can't catch: devmap PMDs and swap PMDs\n(in particular, migration PMDs).\n\nOn \u003c=6.4, this is worse than the first issue: If mfill_atomic() runs on a\nPMD that contains a migration entry (which just requires winning a single,\nfairly wide race), it will pass the PMD to pte_offset_map_lock(), which\nassumes that the PMD points to a page table.\n\nBreakage follows: First, the kernel tries to take the PTE lock (which will\ncrash or maybe worse if there is no \"struct page\" for the address bits in\nthe migration entry PMD - I think at least on X86 there usually is no\ncorresponding \"struct page\" thanks to the PTE inversion mitigation, amd64\nlooks different).\n\nIf that didn't crash, the kernel would next try to write a PTE into what\nit wrongly thinks is a page table.\n\nAs part of fixing these issues, get rid of the check for pmd_trans_huge()\nbefore __pte_alloc() - that's redundant, we're going to have to check for\nthat after the __pte_alloc() anyway.\n\nBackport note: pmdp_get_lockless() is pmd_read_atomic() in older kernels."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: userfaultfd: corregir comprobaciones para PMD enormes Serie de parches \"userfaultfd: corregir ejecucións en torno a la comprobación pmd_trans_huge()\", v2. El código pmd_trans_huge() en mfill_atomic() es incorrecto de tres maneras diferentes según la versión del kernel: 1. La comprobación pmd_trans_huge() es rápida y puede llevar a un BUG_ON() (si alcanza las dos ventanas de ejecución correctas) - He probado esto en una compilación del kernel con algunas llamadas mdelay() adicionales. Vea el mensaje de confirmación para obtener una descripción del escenario de ejecución. En kernels más antiguos (antes de 6.5), creo que el mismo error puede incluso teóricamente llevar a acceder a los contenidos de la página transhuge como una tabla de páginas si alcanza las 5 ventanas de ejecución estrechas correctas (no he probado este caso). 2. Como señaló Qi Zheng, pmd_trans_huge() no es suficiente para detectar PMD que no apuntan a tablas de páginas. En kernels más antiguos (anteriores a 6.5), solo tendrías que ganar una única ejecución bastante amplia para alcanzar esto. He probado esto en 6.1 estable haciendo una ejecución de migración (con un mdelay() parcheado en try_to_migrate()) contra UFFDIO_ZEROPAGE - en mi VM x86, eso causa un error de kernel en ptlock_ptr(). 3. En kernels más nuevos (\u0026gt;=6.5), para asignaciones shmem, khugepaged puede arrancar tablas de páginas de debajo de nosotros (aunque no lo he probado), así que creo que las comprobaciones BUG_ON() en mfill_atomic() son simplemente incorrectas. Decidí escribir dos correcciones separadas para estos (una corrección para los errores 1+2, una corrección para el error 3), de modo que la primera corrección pueda ser retroportada a kernels afectados por errores 1+2. Este parche (de 2): Esto corrige dos problemas. Descubrí que puede ocurrir la siguiente ejecución: mfill_atomic other thread ============ ============  pmdp_get_lockless() [reads none pmd]    __pte_alloc [no-op]   BUG_ON(pmd_none(*dst_pmd)) He verificado esto experimentalmente en un kernel con llamadas mdelay() adicionales; se activa BUG_ON(pmd_none(*dst_pmd)). En los kernels más nuevos que el commit 0d940a9b270b (\"mm/pgtable: permitir que pte_offset_map[_lock]() falle\"), esto no puede llevar a nada peor que un BUG_ON(), ya que los ayudantes de acceso a la tabla de páginas están manipulados para lidiar con la desaparición simultánea de tablas de páginas; pero en kernels más antiguos (\u0026lt;=6.4), creo que probablemente podríamos teóricamente pasar por alto las dos comprobaciones de BUG_ON() y terminar tratando una página enorme como una tabla de páginas. El segundo problema es que, como señaló Qi Zheng, hay otros tipos de PMD enormes que pmd_trans_huge() no puede detectar: PMD de devmap y PMD de intercambio (en particular, PMD de migración). En \u0026lt;=6.4, esto es peor que el primer problema: si mfill_atomic() se ejecuta en un PMD que contiene una entrada de migración (que solo requiere ganar una ejecución única y bastante amplia), pasará el PMD a pte_offset_map_lock(), que asume que el PMD apunta a una tabla de páginas. A continuación, se produce una ruptura: primero, el núcleo intenta tomar el bloqueo PTE (que se bloqueará o tal vez será peor si no hay una \"página de estructura\" para los bits de dirección en el PMD de la entrada de migración; creo que al menos en X86 no suele haber una \"página de estructura\" correspondiente gracias a la mitigación de inversión de PTE; amd64 se ve diferente). Si eso no se bloquea, el núcleo intentará escribir un PTE en lo que cree erróneamente que es una tabla de páginas. Como parte de la solución de estos problemas, elimine la verificación de pmd_trans_huge() antes de __pte_alloc(); eso es redundante, vamos a tener que verificar eso después de __pte_alloc() de todos modos.  --- truncada ----"
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/3c6b4bcf37845c9359aed926324bed66bdd2448d",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/71c186efc1b2cf1aeabfeff3b9bd5ac4c5ac14d8",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/98cc18b1b71e23fe81a5194ed432b20c2d81a01a",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}