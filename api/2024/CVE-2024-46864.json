{
  "id": "CVE-2024-46864",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-09-27T13:15:17.747",
  "lastModified": "2024-09-30T12:45:57.823",
  "vulnStatus": "Awaiting Analysis",
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nx86/hyperv: fix kexec crash due to VP assist page corruption\n\ncommit 9636be85cc5b (\"x86/hyperv: Fix hyperv_pcpu_input_arg handling when\nCPUs go online/offline\") introduces a new cpuhp state for hyperv\ninitialization.\n\ncpuhp_setup_state() returns the state number if state is\nCPUHP_AP_ONLINE_DYN or CPUHP_BP_PREPARE_DYN and 0 for all other states.\nFor the hyperv case, since a new cpuhp state was introduced it would\nreturn 0. However, in hv_machine_shutdown(), the cpuhp_remove_state() call\nis conditioned upon \"hyperv_init_cpuhp \u003e 0\". This will never be true and\nso hv_cpu_die() won't be called on all CPUs. This means the VP assist page\nwon't be reset. When the kexec kernel tries to setup the VP assist page\nagain, the hypervisor corrupts the memory region of the old VP assist page\ncausing a panic in case the kexec kernel is using that memory elsewhere.\nThis was originally fixed in commit dfe94d4086e4 (\"x86/hyperv: Fix kexec\npanic/hang issues\").\n\nGet rid of hyperv_init_cpuhp entirely since we are no longer using a\ndynamic cpuhp state and use CPUHP_AP_HYPERV_ONLINE directly with\ncpuhp_remove_state()."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: x86/hyperv: fix kexec crash due to VP assist page corrupt commit 9636be85cc5b (\"x86/hyperv: Fix hyperv_pcpu_input_arg management when CPUs go online/offline\") introduce un nuevo estado de cpuhp para la inicialización de hyperv. cpuhp_setup_state() devuelve el número de estado si el estado es CPUHP_AP_ONLINE_DYN o CPUHP_BP_PREPARE_DYN y 0 para todos los demás estados. Para el caso de hyperv, dado que se introdujo un nuevo estado de cpuhp, devolvería 0. Sin embargo, en hv_machine_shutdown(), la llamada a cpuhp_remove_state() está condicionada a \"hyperv_init_cpuhp \u0026gt; 0\". Esto nunca será cierto y, por lo tanto, hv_cpu_die() no se llamará en todas las CPU. Esto significa que la página de asistencia de VP no se restablecerá. Cuando el kernel de kexec intenta configurar la página de asistencia de VP nuevamente, el hipervisor corrompe la región de memoria de la página de asistencia de VP anterior, lo que provoca un pánico en caso de que el kernel de kexec esté usando esa memoria en otro lugar. Esto se solucionó originalmente en el commit dfe94d4086e4 (\"x86/hyperv: Fix kexec panic/hang issues\"). Deshágase de hyperv_init_cpuhp por completo, ya que ya no estamos usando un estado de cpuhp dinámico y use CPUHP_AP_HYPERV_ONLINE directamente con cpuhp_remove_state()."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/2ae1beb3ab4f28868cc5d1541d05e1fbee3ad825",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/b9af6418279c4cf73ca073f8ea024992b38be8ab",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/d6f018a3b49d0a94ddbd0e479c2af6b19724e434",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}