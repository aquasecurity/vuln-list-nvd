{
  "id": "CVE-2024-42231",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-07-30T08:15:08.307",
  "lastModified": "2024-07-30T13:32:45.943",
  "vulnStatus": "Undergoing Analysis",
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: zoned: fix calc_available_free_space() for zoned mode\n\ncalc_available_free_space() returns the total size of metadata (or\nsystem) block groups, which can be allocated from unallocated disk\nspace. The logic is wrong on zoned mode in two places.\n\nFirst, the calculation of data_chunk_size is wrong. We always allocate\none zone as one chunk, and no partial allocation of a zone. So, we\nshould use zone_size (= data_sinfo-\u003echunk_size) as it is.\n\nSecond, the result \"avail\" may not be zone aligned. Since we always\nallocate one zone as one chunk on zoned mode, returning non-zone size\naligned bytes will result in less pressure on the async metadata reclaim\nprocess.\n\nThis is serious for the nearly full state with a large zone size device.\nAllowing over-commit too much will result in less async reclaim work and\nend up in ENOSPC. We can align down to the zone size to avoid that."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: btrfs:zoned: fix calc_available_free_space() para el modo zonal calc_available_free_space() devuelve el tamaño total de los grupos de bloques de metadatos (o sistema), que se pueden asignar desde espacio en disco no asignado. La lógica es incorrecta en el modo por zonas en dos lugares. Primero, el cálculo de data_chunk_size es incorrecto. Siempre asignamos una zona como un fragmento y no asignamos una zona parcial. Entonces, deberíamos usar Zone_size (= data_sinfo-\u0026gt;chunk_size) tal como está. En segundo lugar, es posible que el resultado \"avail\" no esté alineado con la zona. Dado que siempre asignamos una zona como un fragmento en el modo de zona, devolver bytes alineados sin tamaño de zona generará menos presión sobre el proceso de recuperación de metadatos asíncronos. Esto es grave para el estado casi lleno con un dispositivo de gran tamaño de zona. Permitir un compromiso excesivo dará como resultado menos trabajo de recuperación asíncrona y terminará en ENOSPC. Podemos alinearnos con el tamaño de la zona para evitar eso."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/64d2c847ba380e07b9072d65a50aa6469d2aa43f",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/8548903b1999bba02a2b894ad750ab8eb1f40307",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}