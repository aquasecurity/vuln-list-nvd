{
  "id": "CVE-2024-42107",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-07-30T08:15:03.220",
  "lastModified": "2024-07-30T13:32:45.943",
  "vulnStatus": "Awaiting Analysis",
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nice: Don't process extts if PTP is disabled\n\nThe ice_ptp_extts_event() function can race with ice_ptp_release() and\nresult in a NULL pointer dereference which leads to a kernel panic.\n\nPanic occurs because the ice_ptp_extts_event() function calls\nptp_clock_event() with a NULL pointer. The ice driver has already\nreleased the PTP clock by the time the interrupt for the next external\ntimestamp event occurs.\n\nTo fix this, modify the ice_ptp_extts_event() function to check the\nPTP state and bail early if PTP is not ready."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: ice: no procesar extts si PTP está deshabilitado. La función ice_ptp_extts_event() puede competir con ice_ptp_release() y provocar una desreferencia del puntero NULL que provoca un pánico en el kernel. El pánico ocurre porque la función ice_ptp_extts_event() llama a ptp_clock_event() con un puntero NULL. El controlador de hielo ya ha liberado el reloj PTP cuando ocurre la interrupción para el siguiente evento de marca de tiempo externo. Para solucionar este problema, modifique la función ice_ptp_extts_event() para verificar el estado de PTP y salir temprano si PTP no está listo."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/1c4e524811918600683b1ea87a5e0fc2db64fa9b",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/996422e3230e41468f652d754fefd1bdbcd4604e",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}