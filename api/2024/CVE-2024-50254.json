{
  "id": "CVE-2024-50254",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-11-09T11:15:11.113",
  "lastModified": "2024-11-14T18:09:48.530",
  "vulnStatus": "Analyzed",
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Free dynamically allocated bits in bpf_iter_bits_destroy()\n\nbpf_iter_bits_destroy() uses \"kit-\u003enr_bits \u003c= 64\" to check whether the\nbits are dynamically allocated. However, the check is incorrect and may\ncause a kmemleak as shown below:\n\nunreferenced object 0xffff88812628c8c0 (size 32):\n  comm \"swapper/0\", pid 1, jiffies 4294727320\n  hex dump (first 32 bytes):\n\tb0 c1 55 f5 81 88 ff ff f0 f0 f0 f0 f0 f0 f0 f0  ..U...........\n\tf0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 00 00 00 00  ..............\n  backtrace (crc 781e32cc):\n\t[\u003c00000000c452b4ab\u003e] kmemleak_alloc+0x4b/0x80\n\t[\u003c0000000004e09f80\u003e] __kmalloc_node_noprof+0x480/0x5c0\n\t[\u003c00000000597124d6\u003e] __alloc.isra.0+0x89/0xb0\n\t[\u003c000000004ebfffcd\u003e] alloc_bulk+0x2af/0x720\n\t[\u003c00000000d9c10145\u003e] prefill_mem_cache+0x7f/0xb0\n\t[\u003c00000000ff9738ff\u003e] bpf_mem_alloc_init+0x3e2/0x610\n\t[\u003c000000008b616eac\u003e] bpf_global_ma_init+0x19/0x30\n\t[\u003c00000000fc473efc\u003e] do_one_initcall+0xd3/0x3c0\n\t[\u003c00000000ec81498c\u003e] kernel_init_freeable+0x66a/0x940\n\t[\u003c00000000b119f72f\u003e] kernel_init+0x20/0x160\n\t[\u003c00000000f11ac9a7\u003e] ret_from_fork+0x3c/0x70\n\t[\u003c0000000004671da4\u003e] ret_from_fork_asm+0x1a/0x30\n\nThat is because nr_bits will be set as zero in bpf_iter_bits_next()\nafter all bits have been iterated.\n\nFix the issue by setting kit-\u003ebit to kit-\u003enr_bits instead of setting\nkit-\u003enr_bits to zero when the iteration completes in\nbpf_iter_bits_next(). In addition, use \"!nr_bits || bits \u003e= nr_bits\" to\ncheck whether the iteration is complete and still use \"nr_bits \u003e 64\" to\nindicate whether bits are dynamically allocated. The \"!nr_bits\" check is\nnecessary because bpf_iter_bits_new() may fail before setting\nkit-\u003enr_bits, and this condition will stop the iteration early instead\nof accessing the zeroed or freed kit-\u003ebits.\n\nConsidering the initial value of kit-\u003ebits is -1 and the type of\nkit-\u003enr_bits is unsigned int, change the type of kit-\u003enr_bits to int.\nThe potential overflow problem will be handled in the following patch."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: bpf: Libera bits asignados dinámicamente en bpf_iter_bits_destroy() bpf_iter_bits_destroy() usa \"kit-\u0026gt;nr_bits \u0026lt;= 64\" para comprobar si los bits están asignados dinámicamente. Sin embargo, la comprobación es incorrecta y puede causar una fuga de kmem como se muestra a continuación: objeto sin referencia 0xffff88812628c8c0 (tamaño 32): comm \"swapper/0\", pid 1, jiffies 4294727320 volcado hexadecimal (primeros 32 bytes): b0 c1 55 f5 81 88 ff ff f0 f0 f0 f0 f0 f0 f0 f0 f0 ..U........... f0 f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 00 00 00 00 .............. backtrace (crc 781e32cc): [\u0026lt;00000000c452b4ab\u0026gt;] kmemleak_alloc+0x4b/0x80 [\u0026lt;0000000004e09f80\u0026gt;] __kmalloc_node_noprof+0x480/0x5c0 [\u0026lt;00000000597124d6\u0026gt;] __alloc.isra.0+0x89/0xb0 [\u0026lt;000000004ebfffcd\u0026gt;] alloc_bulk+0x2af/0x720 [\u0026lt;00000000d9c10145\u0026gt;] prefill_mem_cache+0x7f/0xb0 [\u0026lt;00000000ff9738ff\u0026gt;] bpf_mem_alloc_init+0x3e2/0x610 [\u0026lt;000000008b616eac\u0026gt;] bpf_global_ma_init+0x19/0x30 [\u0026lt;00000000fc473efc\u0026gt;] Esto se debe a que nr_bits se establecerá como cero en bpf_iter_bits_next() después de que se hayan iterado todos los bits. Solucione el problema configurando kit-\u0026gt;bit en kit-\u0026gt;nr_bits en lugar de configurar kit-\u0026gt;nr_bits en cero cuando la iteración se complete en bpf_iter_bits_next(). Además, use \"!nr_bits || bits \u0026gt;= nr_bits\" para verificar si la iteración está completa y siga usando \"nr_bits \u0026gt; 64\" para indicar si los bits se asignan dinámicamente. La verificación \"!nr_bits\" es necesaria porque bpf_iter_bits_new() puede fallar antes de configurar kit-\u0026gt;nr_bits, y esta condición detendrá la iteración antes de tiempo en lugar de acceder a los kit-\u0026gt;bits liberados o puestos a cero. Teniendo en cuenta que el valor inicial de kit-\u0026gt;bits es -1 y el tipo de kit-\u0026gt;nr_bits es unsigned int, cambie el tipo de kit-\u0026gt;nr_bits a int. El posible problema de desbordamiento se manejará en el siguiente parche."
    }
  ],
  "metrics": {
    "cvssMetricV31": [
      {
        "source": "nvd@nist.gov",
        "type": "Primary",
        "cvssData": {
          "version": "3.1",
          "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "attackVector": "LOCAL",
          "attackComplexity": "LOW",
          "privilegesRequired": "LOW",
          "userInteraction": "NONE",
          "scope": "UNCHANGED",
          "confidentialityImpact": "NONE",
          "integrityImpact": "NONE",
          "availabilityImpact": "HIGH",
          "baseScore": 5.5,
          "baseSeverity": "MEDIUM"
        },
        "exploitabilityScore": 1.8,
        "impactScore": 3.6
      }
    ]
  },
  "weaknesses": [
    {
      "source": "nvd@nist.gov",
      "type": "Primary",
      "description": [
        {
          "lang": "en",
          "value": "CWE-401"
        }
      ]
    }
  ],
  "configurations": [
    {
      "nodes": [
        {
          "operator": "OR",
          "negate": false,
          "cpeMatch": [
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
              "matchCriteriaId": "386941FE-51A4-4893-9EC3-054AD3863E8D",
              "versionStartIncluding": "6.11",
              "versionEndExcluding": "6.11.7"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:6.12:rc1:*:*:*:*:*:*",
              "matchCriteriaId": "7F361E1D-580F-4A2D-A509-7615F73167A1"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:6.12:rc2:*:*:*:*:*:*",
              "matchCriteriaId": "925478D0-3E3D-4E6F-ACD5-09F28D5DF82C"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:6.12:rc3:*:*:*:*:*:*",
              "matchCriteriaId": "3C95E234-D335-4B6C-96BF-E2CEBD8654ED"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:6.12:rc4:*:*:*:*:*:*",
              "matchCriteriaId": "E0F717D8-3014-4F84-8086-0124B2111379"
            },
            {
              "vulnerable": true,
              "criteria": "cpe:2.3:o:linux:linux_kernel:6.12:rc5:*:*:*:*:*:*",
              "matchCriteriaId": "24DBE6C7-2AAE-4818-AED2-E131F153D2FA"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/101ccfbabf4738041273ce64e2b116cf440dea13",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    },
    {
      "url": "https://git.kernel.org/stable/c/9cee266fafaf79fd465314546f637f9a3c215830",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "tags": [
        "Patch"
      ]
    }
  ]
}