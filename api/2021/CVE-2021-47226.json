{
  "id": "CVE-2021-47226",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-05-21T15:15:11.823",
  "lastModified": "2024-11-21T06:35:39.977",
  "vulnStatus": "Awaiting Analysis",
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nx86/fpu: Invalidate FPU state after a failed XRSTOR from a user buffer\n\nBoth Intel and AMD consider it to be architecturally valid for XRSTOR to\nfail with #PF but nonetheless change the register state.  The actual\nconditions under which this might occur are unclear [1], but it seems\nplausible that this might be triggered if one sibling thread unmaps a page\nand invalidates the shared TLB while another sibling thread is executing\nXRSTOR on the page in question.\n\n__fpu__restore_sig() can execute XRSTOR while the hardware registers\nare preserved on behalf of a different victim task (using the\nfpu_fpregs_owner_ctx mechanism), and, in theory, XRSTOR could fail but\nmodify the registers.\n\nIf this happens, then there is a window in which __fpu__restore_sig()\ncould schedule out and the victim task could schedule back in without\nreloading its own FPU registers. This would result in part of the FPU\nstate that __fpu__restore_sig() was attempting to load leaking into the\nvictim task's user-visible state.\n\nInvalidate preserved FPU registers on XRSTOR failure to prevent this\nsituation from corrupting any state.\n\n[1] Frequent readers of the errata lists might imagine \"complex\n    microarchitectural conditions\"."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: x86/fpu: Invalida el estado de la FPU después de un XRSTOR fallido desde un búfer de usuario. Tanto Intel como AMD consideran que es arquitectónicamente válido que XRSTOR falle con #PF pero aun así cambie el estado del registro. . Las condiciones reales bajo las cuales esto podría ocurrir no están claras [1], pero parece plausible que esto pueda desencadenarse si un hilo hermano desasigna una página e invalida el TLB compartido mientras otro hilo hermano está ejecutando XRSTOR en la página en cuestión. __fpu__restore_sig() puede ejecutar XRSTOR mientras los registros de hardware se conservan en nombre de una tarea de víctima diferente (usando el mecanismo fpu_fpregs_owner_ctx) y, en teoría, XRSTOR podría fallar pero modificar los registros. Si esto sucede, entonces hay una ventana en la que __fpu__restore_sig() podría programar la salida y la tarea de la víctima podría volver a programarse sin recargar sus propios registros FPU. Esto resultaría en parte del estado de la FPU en el que __fpu__restore_sig() intentaba cargar una filtración en el estado visible para el usuario de la tarea de la víctima. Invalide los registros FPU preservados en caso de falla de XRSTOR para evitar que esta situación corrompa cualquier estado. [1] Los lectores frecuentes de las listas de erratas podrían imaginar \"condiciones microarquitectónicas complejas\"."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/002665dcba4bbec8c82f0aeb4bd3f44334ed2c14",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/a7748e021b9fb7739e3cb88449296539de0b6817",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/d8778e393afa421f1f117471144f8ce6deb6953a",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/002665dcba4bbec8c82f0aeb4bd3f44334ed2c14",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    },
    {
      "url": "https://git.kernel.org/stable/c/a7748e021b9fb7739e3cb88449296539de0b6817",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    },
    {
      "url": "https://git.kernel.org/stable/c/d8778e393afa421f1f117471144f8ce6deb6953a",
      "source": "af854a3a-2127-422b-91ae-364da2661108"
    }
  ]
}