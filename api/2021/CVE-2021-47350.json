{
  "id": "CVE-2021-47350",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-05-21T15:15:21.483",
  "lastModified": "2024-11-04T21:35:01.490",
  "vulnStatus": "Awaiting Analysis",
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc/mm: Fix lockup on kernel exec fault\n\nThe powerpc kernel is not prepared to handle exec faults from kernel.\nEspecially, the function is_exec_fault() will return 'false' when an\nexec fault is taken by kernel, because the check is based on reading\ncurrent-\u003ethread.regs-\u003etrap which contains the trap from user.\n\nFor instance, when provoking a LKDTM EXEC_USERSPACE test,\ncurrent-\u003ethread.regs-\u003etrap is set to SYSCALL trap (0xc00), and\nthe fault taken by the kernel is not seen as an exec fault by\nset_access_flags_filter().\n\nCommit d7df2443cd5f (\"powerpc/mm: Fix spurious segfaults on radix\nwith autonuma\") made it clear and handled it properly. But later on\ncommit d3ca587404b3 (\"powerpc/mm: Fix reporting of kernel execute\nfaults\") removed that handling, introducing test based on error_code.\nAnd here is the problem, because on the 603 all upper bits of SRR1\nget cleared when the TLB instruction miss handler bails out to ISI.\n\nUntil commit cbd7e6ca0210 (\"powerpc/fault: Avoid heavy\nsearch_exception_tables() verification\"), an exec fault from kernel\nat a userspace address was indirectly caught by the lack of entry for\nthat address in the exception tables. But after that commit the\nkernel mainly relies on KUAP or on core mm handling to catch wrong\nuser accesses. Here the access is not wrong, so mm handles it.\nIt is a minor fault because PAGE_EXEC is not set,\nset_access_flags_filter() should set PAGE_EXEC and voila.\nBut as is_exec_fault() returns false as explained in the beginning,\nset_access_flags_filter() bails out without setting PAGE_EXEC flag,\nwhich leads to a forever minor exec fault.\n\nAs the kernel is not prepared to handle such exec faults, the thing to\ndo is to fire in bad_kernel_fault() for any exec fault taken by the\nkernel, as it was prior to commit d3ca587404b3."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se resolvió la siguiente vulnerabilidad: powerpc/mm: corrige el bloqueo en el fallo de ejecución del kernel. El kernel de powerpc no está preparado para manejar fallos de ejecución del kernel. Especialmente, la función is_exec_fault() devolverá 'false' cuando el kernel tome un fallo de ejecución, porque la verificación se basa en la lectura de current-\u0026gt;thread.regs-\u0026gt;trap que contiene la trampa del usuario. Por ejemplo, al provocar una prueba LKDTM EXEC_USERSPACE, current-\u0026gt;thread.regs-\u0026gt;trap se establece en SYSCALL trap (0xc00), y set_access_flags_filter() no ve el error cometido por el kernel como un error de ejecución. La confirmación d7df2443cd5f (\"powerpc/mm: corregir errores de segmentación falsos en radix con autonuma\") lo dejó claro y lo manejó correctamente. Pero más tarde, la confirmación d3ca587404b3 (\"powerpc/mm: corregir informes de fallas de ejecución del kernel\") eliminó ese manejo, introduciendo una prueba basada en error_code. Y aquí está el problema, porque en el 603 todos los bits superiores de SRR1 se borran cuando el controlador de errores de instrucción TLB sale a ISI. Hasta la confirmación cbd7e6ca0210 (\"powerpc/fault: Evite la verificación pesada de search_exception_tables()\"), un fallo de ejecución del kernel en una dirección de espacio de usuario se detectaba indirectamente por la falta de entrada para esa dirección en las tablas de excepción. Pero después de esa confirmación, el kernel depende principalmente de KUAP o del manejo de mm del núcleo para detectar accesos de usuarios incorrectos. Aquí el acceso no es incorrecto, por lo que mm lo maneja. Es un fallo menor porque PAGE_EXEC no está configurada, set_access_flags_filter() debería configurar PAGE_EXEC y listo. Pero como is_exec_fault() devuelve false como se explicó al principio, set_access_flags_filter() sale sin configurar el indicador PAGE_EXEC, lo que conduce a un fallo de ejecución menor para siempre. Como el kernel no está preparado para manejar tales fallos de ejecución, lo que hay que hacer es activar bad_kernel_fault() para cualquier fallo de ejecución tomado por el kernel, como estaba antes de la confirmación d3ca587404b3."
    }
  ],
  "metrics": {
    "cvssMetricV31": [
      {
        "source": "134c704f-9b21-4f2e-91b3-4a467353bcc0",
        "type": "Secondary",
        "cvssData": {
          "version": "3.1",
          "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
          "attackVector": "LOCAL",
          "attackComplexity": "LOW",
          "privilegesRequired": "LOW",
          "userInteraction": "NONE",
          "scope": "UNCHANGED",
          "confidentialityImpact": "NONE",
          "integrityImpact": "NONE",
          "availabilityImpact": "HIGH",
          "baseScore": 5.5,
          "baseSeverity": "MEDIUM"
        },
        "exploitabilityScore": 1.8,
        "impactScore": 3.6
      }
    ]
  },
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/500f81cec9f1bfa5210aa9dd5ba9a06e22f62a35",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/8a96ec5ebf96ad8e2ba7b1b34103a0be5140fc70",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/a82471a14aad90f79d1608d2bcbb019f0ffb53f0",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/cd5d5e602f502895e47e18cd46804d6d7014e65c",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/d2e52d4664097a6c1f591d869ec594bd7a0d4925",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}