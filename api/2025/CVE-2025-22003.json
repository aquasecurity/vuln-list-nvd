{
  "id": "CVE-2025-22003",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-04-03T08:15:15.840",
  "lastModified": "2025-04-07T14:18:34.453",
  "vulnStatus": "Awaiting Analysis",
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\ncan: ucan: fix out of bound read in strscpy() source\n\nCommit 7fdaf8966aae (\"can: ucan: use strscpy() to instead of strncpy()\")\nunintentionally introduced a one byte out of bound read on strscpy()'s\nsource argument (which is kind of ironic knowing that strscpy() is meant\nto be a more secure alternative :)).\n\nLet's consider below buffers:\n\n  dest[len + 1]; /* will be NUL terminated */\n  src[len]; /* may not be NUL terminated */\n\nWhen doing:\n\n  strncpy(dest, src, len);\n  dest[len] = '\\0';\n\nstrncpy() will read up to len bytes from src.\n\nOn the other hand:\n\n  strscpy(dest, src, len + 1);\n\nwill read up to len + 1 bytes from src, that is to say, an out of bound\nread of one byte will occur on src if it is not NUL terminated. Note\nthat the src[len] byte is never copied, but strscpy() still needs to\nread it to check whether a truncation occurred or not.\n\nThis exact pattern happened in ucan.\n\nThe root cause is that the source is not NUL terminated. Instead of\ndoing a copy in a local buffer, directly NUL terminate it as soon as\nusb_control_msg() returns. With this, the local firmware_str[] variable\ncan be removed.\n\nOn top of this do a couple refactors:\n\n  - ucan_ctl_payload-\u003eraw is only used for the firmware string, so\n    rename it to ucan_ctl_payload-\u003efw_str and change its type from u8 to\n    char.\n\n  - ucan_device_request_in() is only used to retrieve the firmware\n    string, so rename it to ucan_get_fw_str() and refactor it to make it\n    directly handle all the string termination logic."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: can: ucan: fix out of bound read in strscpy() source Commit 7fdaf8966aae (\"can: ucan: use strscpy() to instead of strncpy()\") introdujo involuntariamente una lectura fuera de los límite de un byte en el argumento source de strscpy() (lo cual es un poco irónico sabiendo que strscpy() está destinado a ser una alternativa más segura :)). Consideremos los siguientes búferes: dest[len + 1]; /* terminará en NUL */ src[len]; /* puede que no termine en NUL */ Al hacer: strncpy(dest, src, len); dest[len] = '\\0'; strncpy() leerá hasta len bytes desde src. Por otro lado: strscpy(dest, src, len + 1); Leerá hasta len + 1 bytes de src; es decir, se producirá una lectura fuera de los límites de un byte en src si no termina en NUL. Tenga en cuenta que el byte src[len] nunca se copia, pero strscpy() aún necesita leerlo para verificar si se produjo un truncamiento. Este mismo patrón ocurrió en ucan. La causa raíz es que el origen no termina en NUL. En lugar de hacer una copia en un búfer local, termine directamente en NUL tan pronto como usb_control_msg() regrese. Con esto, se puede eliminar la variable local firmware_str[]. Además, realice un par de refactorizaciones: - ucan_ctl_payload-\u0026gt;raw solo se usa para la cadena de firmware, así que renómbrelo a ucan_ctl_payload-\u0026gt;fw_str y cambie su tipo de u8 a char. - ucan_device_request_in() solo se utiliza para recuperar la cadena de firmware, así que cámbiele el nombre a ucan_get_fw_str() y refactorícelo para que gestione directamente toda la lógica de terminación de la cadena."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/1d22a122ffb116c3cf78053e812b8b21f8852ee9",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/8cec9e314d3360fc1d8346297c41a6ee45cb45a9",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/a4994161a61bc8fd71d105c579d847cefee99262",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/cc29775a8a72d7f3b56cc026796ad99bd65804a7",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}