{
  "id": "CVE-2025-38305",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2025-07-10T08:15:29.320",
  "lastModified": "2025-07-10T13:17:30.017",
  "vulnStatus": "Awaiting Analysis",
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nptp: remove ptp-\u003en_vclocks check logic in ptp_vclock_in_use()\n\nThere is no disagreement that we should check both ptp-\u003eis_virtual_clock\nand ptp-\u003en_vclocks to check if the ptp virtual clock is in use.\n\nHowever, when we acquire ptp-\u003en_vclocks_mux to read ptp-\u003en_vclocks in\nptp_vclock_in_use(), we observe a recursive lock in the call trace\nstarting from n_vclocks_store().\n\n============================================\nWARNING: possible recursive locking detected\n6.15.0-rc6 #1 Not tainted\n--------------------------------------------\nsyz.0.1540/13807 is trying to acquire lock:\nffff888035a24868 (\u0026ptp-\u003en_vclocks_mux){+.+.}-{4:4}, at:\n ptp_vclock_in_use drivers/ptp/ptp_private.h:103 [inline]\nffff888035a24868 (\u0026ptp-\u003en_vclocks_mux){+.+.}-{4:4}, at:\n ptp_clock_unregister+0x21/0x250 drivers/ptp/ptp_clock.c:415\n\nbut task is already holding lock:\nffff888030704868 (\u0026ptp-\u003en_vclocks_mux){+.+.}-{4:4}, at:\n n_vclocks_store+0xf1/0x6d0 drivers/ptp/ptp_sysfs.c:215\n\nother info that might help us debug this:\n Possible unsafe locking scenario:\n\n       CPU0\n       ----\n  lock(\u0026ptp-\u003en_vclocks_mux);\n  lock(\u0026ptp-\u003en_vclocks_mux);\n\n *** DEADLOCK ***\n....\n============================================\n\nThe best way to solve this is to remove the logic that checks\nptp-\u003en_vclocks in ptp_vclock_in_use().\n\nThe reason why this is appropriate is that any path that uses\nptp-\u003en_vclocks must unconditionally check if ptp-\u003en_vclocks is greater\nthan 0 before unregistering vclocks, and all functions are already\nwritten this way. And in the function that uses ptp-\u003en_vclocks, we\nalready get ptp-\u003en_vclocks_mux before unregistering vclocks.\n\nTherefore, we need to remove the redundant check for ptp-\u003en_vclocks in\nptp_vclock_in_use() to prevent recursive locking."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: ptp: eliminar la lógica de comprobación de ptp-\u0026gt;n_vclocks en ptp_vclock_in_use(). No hay desacuerdo en que debemos comprobar tanto ptp-\u0026gt;is_virtual_clock como ptp-\u0026gt;n_vclocks para comprobar si el reloj virtual ptp está en uso. Sin embargo, al adquirir ptp-\u0026gt;n_vclocks_mux para leer ptp-\u0026gt;n_vclocks en ptp_vclock_in_use(), observamos un bloqueo recursivo en el seguimiento de llamadas a partir de n_vclocks_store(). ============================================== ADVERTENCIA: posible bloqueo recursivo detectado 6.15.0-rc6 #1 No contaminado -------------------------------------------- syz.0.1540/13807 está intentando adquirir el bloqueo: ffff888035a24868 (\u0026amp;ptp-\u0026gt;n_vclocks_mux){+.+.}-{4:4}, en: ptp_vclock_in_use drivers/ptp/ptp_private.h:103 [en línea] ffff888035a24868 (\u0026amp;ptp-\u0026gt;n_vclocks_mux){+.+.}-{4:4}, en: ptp_clock_unregister+0x21/0x250 drivers/ptp/ptp_clock.c:415 pero la tarea ya tiene el bloqueo: ffff888030704868 (\u0026amp;ptp-\u0026gt;n_vclocks_mux){+.+.}-{4:4}, en: n_vclocks_store+0xf1/0x6d0 drivers/ptp/ptp_sysfs.c:215 otra información que podría ayudarnos a depurar esto: Posible escenario de bloqueo inseguro: CPU0 ---- lock(\u0026amp;ptp-\u0026gt;n_vclocks_mux); lock(\u0026amp;ptp-\u0026gt;n_vclocks_mux); *** BLOQUEO INTERMEDIO *** .... ============================================== La mejor manera de resolver esto es eliminar la lógica que comprueba ptp-\u0026gt;n_vclocks en ptp_vclock_in_use(). Esto es apropiado porque cualquier ruta que use ptp-\u0026gt;n_vclocks debe comprobar incondicionalmente si ptp-\u0026gt;n_vclocks es mayor que 0 antes de anular el registro de vclocks, y todas las funciones ya están escritas de esta manera. En la función que usa ptp-\u0026gt;n_vclocks, ya obtenemos ptp-\u0026gt;n_vclocks_mux antes de anular el registro de vclocks. Por lo tanto, necesitamos eliminar la comprobación redundante de ptp-\u0026gt;n_vclocks en ptp_vclock_in_use() para evitar el bloqueo recursivo."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/259119595227fd20f6aa29d85abe086b6fdd9eb1",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/5d217e7031a5c06d366580fc6ddbf43527b780d4",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/87f7ce260a3c838b49e1dc1ceedf1006795157a2",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/b1b73c452331451020be3bf4b014901015ae6663",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/b93e6fef4eda48e17d9c642b9abad98a066fd4a3",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/ef8fc007c28a30a4c0d90bf755e0f343d99bb392",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}