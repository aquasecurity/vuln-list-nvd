{
  "id": "CVE-2023-52897",
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "published": "2024-08-21T07:15:06.120",
  "lastModified": "2024-08-21T07:15:06.120",
  "vulnStatus": "Received",
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: qgroup: do not warn on record without old_roots populated\n\n[BUG]\nThere are some reports from the mailing list that since v6.1 kernel, the\nWARN_ON() inside btrfs_qgroup_account_extent() gets triggered during\nrescan:\n\n  WARNING: CPU: 3 PID: 6424 at fs/btrfs/qgroup.c:2756 btrfs_qgroup_account_extents+0x1ae/0x260 [btrfs]\n  CPU: 3 PID: 6424 Comm: snapperd Tainted: P           OE      6.1.2-1-default #1 openSUSE Tumbleweed 05c7a1b1b61d5627475528f71f50444637b5aad7\n  RIP: 0010:btrfs_qgroup_account_extents+0x1ae/0x260 [btrfs]\n  Call Trace:\n   \u003cTASK\u003e\n  btrfs_commit_transaction+0x30c/0xb40 [btrfs c39c9c546c241c593f03bd6d5f39ea1b676250f6]\n   ? start_transaction+0xc3/0x5b0 [btrfs c39c9c546c241c593f03bd6d5f39ea1b676250f6]\n  btrfs_qgroup_rescan+0x42/0xc0 [btrfs c39c9c546c241c593f03bd6d5f39ea1b676250f6]\n   btrfs_ioctl+0x1ab9/0x25c0 [btrfs c39c9c546c241c593f03bd6d5f39ea1b676250f6]\n   ? __rseq_handle_notify_resume+0xa9/0x4a0\n   ? mntput_no_expire+0x4a/0x240\n   ? __seccomp_filter+0x319/0x4d0\n   __x64_sys_ioctl+0x90/0xd0\n   do_syscall_64+0x5b/0x80\n   ? syscall_exit_to_user_mode+0x17/0x40\n   ? do_syscall_64+0x67/0x80\n  entry_SYSCALL_64_after_hwframe+0x63/0xcd\n  RIP: 0033:0x7fd9b790d9bf\n   \u003c/TASK\u003e\n\n[CAUSE]\nSince commit e15e9f43c7ca (\"btrfs: introduce\nBTRFS_QGROUP_RUNTIME_FLAG_NO_ACCOUNTING to skip qgroup accounting\"), if\nour qgroup is already in inconsistent state, we will no longer do the\ntime-consuming backref walk.\n\nThis can leave some qgroup records without a valid old_roots ulist.\nNormally this is fine, as btrfs_qgroup_account_extents() would also skip\nthose records if we have NO_ACCOUNTING flag set.\n\nBut there is a small window, if we have NO_ACCOUNTING flag set, and\ninserted some qgroup_record without a old_roots ulist, but then the user\ntriggered a qgroup rescan.\n\nDuring btrfs_qgroup_rescan(), we firstly clear NO_ACCOUNTING flag, then\ncommit current transaction.\n\nAnd since we have a qgroup_record with old_roots = NULL, we trigger the\nWARN_ON() during btrfs_qgroup_account_extents().\n\n[FIX]\nUnfortunately due to the introduction of NO_ACCOUNTING flag, the\nassumption that every qgroup_record would have its old_roots populated\nis no longer correct.\n\nFix the false alerts and drop the WARN_ON()."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se resolvió la siguiente vulnerabilidad: btrfs: qgroup: no advertir en el registro sin old_roots poblado [ERROR] Hay algunos informes de la lista de correo que desde el kernel v6.1, WARN_ON() dentro de btrfs_qgroup_account_extent() se activa durante la nueva exploración: ADVERTENCIA: CPU: 3 PID: 6424 en fs/btrfs/qgroup.c:2756 btrfs_qgroup_account_extents+0x1ae/0x260 [btrfs] CPU: 3 PID: 6424 Comm: snapperd Contaminado: P OE 6.1.2-1- predeterminado #1 openSUSE Tumbleweed 05c7a1b1b61d5627475528f71f50444637b5aad7 RIP: 0010:btrfs_qgroup_account_extents+0x1ae/0x260 [btrfs] Seguimiento de llamadas:  btrfs_commit_transaction+0x30c/0xb40 c39c9c546c241c593f03bd6d5f39ea1b676250f6] ? start_transaction+0xc3/0x5b0 [btrfs c39c9c546c241c593f03bd6d5f39ea1b676250f6] btrfs_qgroup_rescan+0x42/0xc0 [btrfs c39c9c546c241c593f03bd6d5f39ea1b676250f 6]btrfs_ioctl+0x1ab9/0x25c0 [btrfs c39c9c546c241c593f03bd6d5f39ea1b676250f6]? __rseq_handle_notify_resume+0xa9/0x4a0 ? mntput_no_expire+0x4a/0x240? __seccomp_filter+0x319/0x4d0 __x64_sys_ioctl+0x90/0xd0 do_syscall_64+0x5b/0x80 ? syscall_exit_to_user_mode+0x17/0x40? do_syscall_64+0x67/0x80 Entry_SYSCALL_64_after_hwframe+0x63/0xcd RIP: 0033:0x7fd9b790d9bf  [CAUSA] Desde el commit e15e9f43c7ca (\"btrfs: introduzca BTRFS_QGROUP_RUNTIME_FLAG_NO_ACCOUNTING para omitir la contabilidad de qgroup\"), si qgroup ya está en estado inconsistente, no lo haremos Ya no hagas la larga caminata hacia atrás. Esto puede dejar algunos registros de qgroup sin una lista old_roots válida. Normalmente, esto está bien, ya que btrfs_qgroup_account_extents() también omitiría esos registros si tenemos configurado el indicador NO_ACCOUNTING. Pero hay una pequeña ventana, si tenemos el indicador NO_ACCOUNTING configurado e insertamos algún qgroup_record sin una lista old_roots, pero luego el usuario activó una nueva exploración de qgroup. Durante btrfs_qgroup_rescan(), primero borramos el indicador NO_ACCOUNTING y luego confirmamos la transacción actual. Y como tenemos un qgroup_record con old_roots = NULL, activamos WARN_ON() durante btrfs_qgroup_account_extents(). [FIX] Desafortunadamente, debido a la introducción del indicador NO_ACCOUNTING, la suposición de que cada qgroup_record tendría sus old_roots completadas ya no es correcta. Corrija las alertas falsas y elimine WARN_ON()."
    }
  ],
  "metrics": {},
  "references": [
    {
      "url": "https://git.kernel.org/stable/c/75181406b4eafacc531ff2ee5fb032bd93317e2b",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    },
    {
      "url": "https://git.kernel.org/stable/c/bb2c2e62539f2b63c5e0beb51501d328260c7595",
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"
    }
  ]
}